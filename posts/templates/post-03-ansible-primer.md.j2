{% extends 'base.md.j2' %}
{% block lead_paragraph %}
This post serves as an Ansible primer. It assumes shell knowledge but nothing else. The post looks at each component of an Ansible playbook with plenty of examples. It doesn't explain any of the Ansible modules in detail, but does occasionally investigate how Ansible core works. If you're already familiar with Ansible, you can probably skip this. I removed anything involving the overarching project to simplify things.

**WARNING:** If you're still seeing this message, the post is in the draft stage. Expect everything to change.
{% endblock %}
{% block content %}

## Ansible

Ansible is great. Using basic markup, you can script most of the things you can think of doing via a good command line (so not PowerShell). It even got me to begrudgingly learn Python. Rather than waste time gushing about how easy it is to use and how much it can change your life, I'll jump right in.

## Configuration

If you're a masochist and enjoy manually specifying every option and every flag on every Ansible command directly, skip this section. If that doesn't sound fun, you can instead use a configuration file to [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) your scripting.

[Out of the box](http://docs.ansible.com/ansible/latest/intro_configuration.html), Ansible loads its (possibly empty) global configuration file, `/etc/ansible/ansible.cfg`. If you're working in a shared environment, or previously set up Ansible, Ansible might load an environment or userspace config file instead. Luckily, Ansible conveniently provides its discovered config with the `--version` flag:

{{ shell_block('''
$ ansible --version
ansible 2.4.1.0
  config file = None
  ...
$ touch ~/.ansible.cfg
$ ansible --version
ansible 2.4.1.0
  config file = /home/user/.ansible.cfg
  ...
'''.encode('utf-8')) }}

Ansible only loads the first file it finds. It won't merge, say, a local directory config and your global `$HOME` config. Ansible starts with [its base configuration](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/config/base.yml) and updates only the values you've specified. If you're not paying attention, this can often bite you. For example, the default inventory, `/etc/ansible/hosts`, probably doesn't contain the hosts you're about to set up. You'll either have to specify a local inventory at execution via the `-i`nventory flag always or add `inventory = /path/to/inventory` to the project's main config file once. I prefer the latter option.

### `ansible-config`

If you're using Ansible `>=2.4`, you can quickly verify config via `ansible-config`. If you're not using Ansible `>=2.4` and don't have a serious architecture reason to resist change, pause, go update Ansible, and come back.

The `--only-changed` flag with `dump` is mind-blowingly useful when trying to figure out what's not stock:

{{ shell_block('''
$ ansible-config dump --only-changed
'''.encode('utf-8')) }}

You can also view the entire configuration, which is just as insanely useful for debugging as the `--only-changed` refinement.

## Inventory

[Ansible's inventory](http://docs.ansible.com/ansible/latest/intro_inventory.html) provides all the information necessary to manage the desired machines, local or remote. You'll need to add things like addresses and usernames, so be careful with its contents. I personally wouldn't store that information, even encrypted, in a public repo, but YMMV.

(Quick aside: You can also use [dynamic inventories](http://docs.ansible.com/ansible/latest/intro_dynamic_inventory.html), generated from local code or API returns. I really want to try this, and might hit it later.)

While inventories can be one of many supported filetypes, I'll be using YAML files. I find it easier to keep track of all the Ansible configuration when I don't have to swap between syntaxes (as similar as they are).

The first component of an inventory entry ([in YAML, at least](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/plugins/inventory/yaml.py#L97)) is the owning group. `all` is a magic group that can be used when you don't want to explicitly name the group of hosts; even if you don't use it, `all` will get all the hosts in the inventory.

```yaml
---
my_first_group:
  # ...
all:
  # ...
  # also magically contains my_first_group
```

Below the group is its defining characteristics such as its child `hosts`, any `children` groups, and group-scope `vars`.

```yaml
---
all:
  hosts:
    specific_host:
      # ...
    other_host:
      # ...
  children:
    child_group:
      hosts:
        turtles_all_the_way_down:
          # ...
  vars:
    group_scoped_variable: 'can be overriden per host'
```

Each of the `hosts` may redefine [connection behavior](http://docs.ansible.com/ansible/latest/intro_inventory.html#list-of-behavioral-inventory-parameters) and can also defined host-specific variables (not related to Ansible):

```yaml
---
all:
  hosts:
    specific_host:
      ansible_user: cool_user
      host_scoped_variable: 'not accessible to its group'
```

To make managing all of this information easier, you can split out group and host `vars`. Ansible searches for `group_vars/groupname.yml` and `host_vars/hostname.yml` in the `inventory` path. If found, Ansible merges those `vars` in with the variables defined in the `inventory_file`.

{{ shell_block('''
$ tree example-inventory
example_inventory
├── group_vars
│   ├── all.yml
│   └── named_group.yml
├── host_vars
│   └── specific_hostname.yml
├── named_group.yml
└── ungrouped.yml

2 directories, 5 files
'''.encode('utf-8')) }}

[The precedence](http://docs.ansible.com/ansible/latest/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable) might be surprising: facts from an inventory file are replaced by facts from `(group|host)_vars`. Using the above example, these values represent the final value of facts defined in multiple locations (assuming they're only set in the inventory):

```yaml
---
# Set in:
# - under named_group vars in named_group.yml
group_inventory_final_say: 'named_group.yml'

# Set in:
# - under named_group vars in named_group.yml
# - group_vars/all.yml
all_group_vars_final_say: 'group_vars/all.yml'

# Set in:
# - under named_group vars in named_group.yml
# - group_vars/all.yml
# - group_vars/named_group.yml
group_vars_final_say: 'group_vars/named_group.yml'

# Set in:
# - under named_group vars in named_group.yml
# - group_vars/all.yml
# - group_vars/named_group.yml
# - under specific_hostname (directly) in named_group.yml
host_inventory_final_say: 'named_group.yml'

# Set in:
# - under named_group vars in named_group.yml
# - group_vars/all.yml
# - group_vars/named_group.yml
# - under specific_hostname (directly) in named_group.yml
# - host_vars/specific_hostname.yml
host_vars_final_say: 'host_vars/specific_hostname.yml'
```

## Ad-Hoc Commands

Ansible exposes its API for quick access via [ad-hoc commands](http://docs.ansible.com/ansible/latest/intro_adhoc.html). Ad-hoc commands aren't run as part of a playbook, so they're very useful for debugging or one-off calls. Similar to tasks inside a playbook (explained [later](#playbooks)), you must specify the host(s), the module, and its arguments.

{{ shell_block('''
$ ansible <host or group> -m <module name> -a "<arguments to pass to the module>"
'''.encode('utf-8')) }}

A common "hello world" command uses [the `ping` module](http://docs.ansible.com/ansible/latest/ping_module.html):

{{ shell_block('''
$ ansible --connection=local localhost -m ping
localhost | SUCCESS => {
    "changed": false,
    "failed": false,
    "ping": "pong"
}
'''.encode('utf-8')) }}

[The `debug` module](http://docs.ansible.com/ansible/latest/debug_module.html) provides a fast way to view variables. For example, let's check a few Ansible variables against `localhost`:

{{ shell_block('''
$ ansible --connection=local localhost -m debug -a \'msg="Host is {{ ansible_host }} as {{ inventory_hostname }} defined {{ \\"locally\\" if inventory_file is not defined else (\\"in \\" + inventory_file) }}"\'
localhost | SUCCESS => {
    "msg": "Host is 127.0.0.1 as localhost defined locally"
}
'''.encode('utf-8')) }}

There are no ad-hoc commands in [the actual codebase]({{  github_path(current_tag, 'provisioning') }}), as the calls are all in playbooks or roles. However, I might occasionally use an ad-hoc command to illustrate a task, and I highly recommend running tasks here as commands to understand how they work.

## Playbooks

Ansible proper runs blocks of actions on hosts in [YAML files called playbooks](http://docs.ansible.com/ansible/latest/playbooks_intro.html). Playbooks are lists of plays, which contain targets, variables, and actions to execute. [The previous section](#adhoccommands) can be rewritten as follows:

{% raw %}
```yaml
---
- hosts: localhost
  connection: local

  tasks:
    - name: Ping the host
      ping:
    - name: Print hostname metadata
      debug:
        msg: "Host is {{ ansible_host }} as {{ inventory_hostname }} defined {{ 'locally' if inventory_file is not defined else ('in ' + inventory_file) }}"
```
{% endraw %}

When run, it looks something like this:

{{ shell_block('''
$ ansible-playbook scratch.yml
PLAY [localhost] **********************************************************

TASK [Gathering Facts] ****************************************************
ok: [localhost]

TASK [Ping the host] *****************************************************
ok: [localhost]

TASK [Print hostname metadata] ********************************************
ok: [localhost] => {
    "msg": "Host is 127.0.0.1 as localhost defined locally"
}

PLAY RECAP ****************************************************************
localhost                  : ok=3    changed=0    unreachable=0    failed=0
'''.encode('utf-8')) }}

### Jinja2

Ansible templates playbooks (and related files) via [Jinja2](http://jinja.pocoo.org/). [The docs](http://docs.ansible.com/ansible/latest/playbooks_templating.html) include wonderfully handy details, like [useful transformation filters](http://docs.ansible.com/ansible/latest/playbooks_filters.html) (which links [Jinja2's built-in filters](http://jinja.pocoo.org/docs/2.10/templates/#builtin-filters), an equally handy read). I'm just going to explain Jinja2 basics in Ansible here, as covering [a rich templating engine](http://jinja.pocoo.org/docs/2.10/api/) is beyond the scope of this post and project.

Jinja2 searches each template for {{ '`{{ <expression> }}`' }} (actual templates might [include other delimiters](http://jinja.pocoo.org/docs/2.10/templates/#synopsis), e.g. when using [the `template` module](http://docs.ansible.com/ansible/latest/template_module.html)). For the most part, these are [variables to replace](http://jinja.pocoo.org/docs/2.10/templates/#variables), possibly after applying [a filter](http://jinja.pocoo.org/docs/2.10/templates/#filters), but Jinja2 expressions can also include valid code so long as it returns a value (I think; I don't know enough about Python yet to really explore potential counter-examples).

All of Ansible's playbook YAML files are rendered with Jinja2 before being sent to the target (I believe that logic is [here](https://github.com/ansible/ansible/tree/v2.4.1.0-1/lib/ansible/template); those classes showed up elsewhere while investigating playbook execution). Recent versions of Ansible have begun to include some template style feedback (e.g. [no templates in conditionals](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/playbook/conditional.py#L131)), but, for the most part, you're on your own.

Personally, I wrap anything templated in double quotes, e.g. {{ '`"{{ variable_name }}"`'}}, which means I can quickly distinguish between strings that are templated and those that are not, i.e. {{ '`"is {{ \'templated\' }}"`' }} vs `'is not templated'`. Ansible's [interpretation of the YAML spec](https://github.com/ansible/ansible/tree/v2.4.1.0-1/lib/ansible/parsing/yaml) is fairly loose (as is [the spec](https://www.reddit.com/r/programming/comments/7ctwi7/yaml_sucks/)); the docs highlight [a few important gotchas](http://docs.ansible.com/ansible/latest/YAMLSyntax.html).

{% raw %}
```yaml
---
not_parsed: this entire string
easier_to_skim_not_parsed: 'this entire string'

user_config_directory: "/home/{{ ansible_user }}/.config"
# /home/me/.config

important_value: None
important_setting: "{{ important_value|default('not that important i guess', true) }}"
# not that important i guess

number_of_seconds_in_a_day_usually: "{{ 60 * 60 * 24 }}"
# 86400

a_dict:
  property_one: yes
  property_two: no
templated_dict: "{{ a_dict }}"
# { 'property_one': true, 'property_two': false }

a_list:
  - one
  - two
templated_list: "{{ a_list }}"
# [ 'one', 'two' ]
```
{% endraw %}

### Play Meta

The first (logically, at least) components of a play are its metadata. A play first lists its targets, defines local variables (including overriding inherited values), and [gathers pertinent host facts](http://docs.ansible.com/ansible/latest/setup_module.html).

Plays begin with a `hosts` variable, which can be a specific host, a group, or [a group pattern](http://docs.ansible.com/ansible/latest/intro_patterns.html). As of `2.4`, you can additionally [specify the `order`](http://docs.ansible.com/ansible/latest/playbooks_intro.html#hosts-and-users) a group will follow. [By default](http://docs.ansible.com/ansible/latest/playbooks_variables.html#information-discovered-from-systems-facts), each play will attempt to gather information about all the targeted hosts. If you don't want Ansible to do this, e.g. the play doesn't need any host information, you can disable it with `gather_facts: no`.

```yaml
---
- hosts: specific-host
  ...
- hosts: some-group
  ...
- hosts: all:!except-for-this-host
  ...
- hosts: all
  gather_facts: no
  ...
```

Plays can (re)define a variety of Ansible options, which come from its superclasses `Base` ([source](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/playbook/base.py#L150)), `Taggable`([source](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/playbook/taggable.py#L30)), and `Become` ([source](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/playbook/become.py#L33)). Plays inherit the options defined in the inventory. Anything specified in a play will override the inventory value, e.g. a play's `remote_user` will replace a host's `ansible_user`.

```yaml
...
  tags:
    - 'is_tagged'
  remote_user: differentuser
  connection: docker
...
```

(Full disclosure: I couldn't actually find a full list of play options [in the docs](http://docs.ansible.com/ansible/latest/playbooks.html) when I started this project. I did find [host options](http://docs.ansible.com/ansible/latest/intro_inventory.html#list-of-behavioral-inventory-parameters), so I just used those. I just now, while writing this post, discovered all the cool things available by delving in the source code. I suppose I should have done that sooner.)

Like hosts, plays can define `vars` or [include external `vars`](http://docs.ansible.com/ansible/latest/playbooks_variables.html#variable-file-separation). As usual, these will override host values.

```yaml
...
  vars:
    play_scoped_value: 'accessible to its child elements'
    host_scoped_value: 'replaces the host value'
  var_files:
    - /path/to/a/vars/file.yml
...
```

### Tasks

Plays execute a collection of actions, called `tasks`, against their `hosts`. For convenience, Ansible provides three `tasks` blocks, `pre_tasks`, `tasks`, and `post_tasks`, executed [in that order](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/playbook/play.py#L271). `tasks` are [a list of module calls](http://docs.ansible.com/ansible/latest/playbooks_intro.html#tasks-list). You can get a list of installed modules via `ansible-doc -l`, browse its documentation via `ansible-doc <module name>`, and test its syntax via [ad-hoc usage](#adhoccommands). The list of modules [online in the docs](http://docs.ansible.com/ansible/latest/list_of_all_modules.html) may or may not be current, and won't include any extensions you've installed locally.

Task attributes are defined [locally](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/playbook/task.py#L69) and in its superclasses `Base` ([source](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/playbook/base.py#L150)), `Conditional` ([source](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/playbook/conditional.py#L45)), `Taggable`([source](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/playbook/taggable.py#L30)), and `Become` ([source](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/playbook/become.py#L33)). The simplest task form is just a module call:

```yaml
...
  tasks:
    - debug:
        msg: 'barebones'
...
```

In practice, it's usually a good idea to at least provide a `name` for logging:

```yaml
...
  tasks:
    - name: Log a simple message
      debug:
        msg: 'barebones with name'
...
```

{{ shell_block('''
$ ansible-playbook scratch.yml
PLAY **********************************************************************

TASK [setup] **************************************************************
ok: [localhost]

TASK [debug] **************************************************************
ok: [localhost] => {
    "msg": "barebones"
}

TASK [Log a simple message] ***********************************************
ok: [localhost] => {
    "msg": "barebones with name"
}

PLAY RECAP ****************************************************************
localhost                  : ok=3    changed=0    unreachable=0    failed=0
'''.encode('utf-8')) }}

It's often useful to pass information from one task to another. Each module returns the result (if any) of its action (check its format via `ansible-doc` or the online docs) as well as [common values](http://docs.ansible.com/ansible/latest/common_return_values.html). Usually, you're getting [the result of `AnsibleModule.run_command`](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/module_utils/basic.py#L2559) after the module processes its results. To access this return elsewhere, include `register: name_to_register_as`, which [creates a new fact](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/plugins/strategy/__init__.py#L368) scoped to the play, i.e. accessible to tasks within the play but not elsewhere.

(Quick aside: The scope works because, as the `variable_manager` is passed around, it is [serialized via `pickle`](https://docs.python.org/2/library/pickle.html) and, [when deserialized](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/vars/manager.py#L144), the nonpersistent cache is initialized to an empty `dict`. If that explanation is wrong, I apologize; I don't fully grok the process and am making a few logical jumps based off the code I was able to figure out and trace.)

```yaml
...
  tasks:
    - name: Illustrate registering a task's output
      stat:
        path: /tmp/provisioning
      register: demo_register

    # This puts the item in the logs
    # Alternatively, you could just run the playbook verbosely
    - name: Output previous result
      debug:
        var: demo_register
...
```

{{ shell_block('''
$ ansible-playbook scratch.yml
PLAY **********************************************************************

TASK [setup] **************************************************************
ok: [localhost]

TASK [Illustrate registering a task\'s output] *****************************
ok: [localhost]

TASK [Output previous result] *********************************************
ok: [localhost] => {
    "demo_register": {
        "changed": false,
        "stat": {
            "exists": false
        }
    }
}

PLAY RECAP ****************************************************************
localhost                  : ok=3    changed=0    unreachable=0    failed=0
'''.encode('utf-8')) }}

Tasks can be run conditionally via `when`. There are plenty of good reasons for conditional tasks, like performing OS-specific actions, running state-dependent processes, or including/excluding items based on local facts. Tasks whose execution is dependent on the status of other tasks are better handled (pun intended) via [Handlers](#handlers).

{% raw %}
```yaml
...
  vars:
    max_cache_age: "{{ 60 * 60 * 24 * 7 }}"
    cachefile_path: /tmp/cachefile
    true_in_ancestor: false

  tasks:
    - name: Badger Windows users
      debug:
        msg: You should consider using a more pleasant, less proprietary operating system.
      # The regex_search filter returns matched contents if found and None otherwise
      when: (ansible_distribution|regex_search('([mM]icrosoft|[wW]indows)')) or (ansible_bios_version|regex_search('([hH]yper-[vV])'))

    - name: Check cache age
      stat:
        path: "{{ cachefile_path }}"
      register: cache_age

    - name: Nuke stale cache
      copy:
        content: ''
        dest: "{{ cachefile_path }}"
        force: yes
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: 'ugo=rw'
      when: cache_age.stat.exists == false or cache_age.stat.mtime|int < (ansible_date_time.epoch|int - max_cache_age|int)

    - name: Run when local fact is truthy
      expect:
        command: passwd AzureDiamond
        responses:
          (?i)password: 'hunter2'
      when: true_in_ancestor
...
```
{% endraw %}

{{ shell_block('''
$ ansible-playbook scratch.yml
PLAY [localhost] **********************************************************

TASK [Gathering Facts] ****************************************************
ok: [localhost]

TASK [Badger Windows users] ***********************************************
skipping: [localhost]

TASK [Check cache age] ****************************************************
ok: [localhost]

TASK [Nuke stale cache] ***************************************************
skipping: [localhost]

TASK [Run when local fact is truthy] **************************************
skipping: [localhost]

PLAY RECAP ****************************************************************
localhost                  : ok=2    changed=0    unreachable=0    failed=0
'''.encode('utf-8')) }}

Tasks can also be [looped via `with_items`](http://docs.ansible.com/ansible/latest/playbooks_loops.html). This makes duplicating tasks much easier, and also allows each task to focus solely on a single action. The task iterates of the contents of `with_items`, (coerced to) a list, using `item` as a placeholder. ([The loop docs](http://docs.ansible.com/ansible/latest/playbooks_loops.html) cover other very useful possibilities, like `with_filetree` and renaming `loop_var`; RTFM) For example, the [suggested way to install packages](http://docs.ansible.com/ansible/latest/playbooks_loops.html#standard-loops) (on targets whose shell can install packages by default, so not Windows) looks like this:

{% raw %}
```yaml
...
  tasks:
    - name: Ensure dependencies are installed
      package:
        name: "{{ item }}"
        state: present
      with_items:
        - git
        - bash
      become: yes
...
```
{% endraw %}

{{ shell_block('''
$ ansible-playbook provisioning/scratch.yml --ask-become-pass
SUDO password:

PLAY [localhost] **********************************************************

TASK [Gathering Facts] ****************************************************
ok: [localhost]

TASK [Ensure dependencies are installed] **********************************
ok: [localhost] => (item=git)
ok: [localhost] => (item=bash)

PLAY RECAP ****************************************************************
localhost                  : ok=2    changed=0    unreachable=0    failed=0
'''.encode('utf-8')) }}

### Handlers

[Handlers](http://docs.ansible.com/ansible/latest/playbooks_intro.html#handlers-running-operations-on-change) are a specific subclass of tasks whose purpose is to execute task-state-dependent tasks. That's a lot to unpack, so let's look at the most common example:

```yaml
...
  tasks:
    - name: Ensure templated config is in place
      template:
        src: etc/some/service.conf.j2
        dest: /etc/some/service.conf
      register: some_service_config

    - name: Reload some-service on config change
      service:
        name: some-service
        state: restarted
      when: some_service_config|changed
...
```
This play templates the config for `some-service`, and, if the file changed, restarts `some-service`. Ansible will always attempt to run the second task, skipping it when nothing changed, as you can see below:

{{ shell_block('''
$ ansible-playbook scratch.yml
PLAY [localhost] **********************************************************

TASK [Gathering Facts] ****************************************************
ok: [localhost]

TASK [Ensure templated config is in place] ********************************
ok: [localhost]

TASK [Reload some-service on config change] *******************************
ok: [localhost]

PLAY RECAP ****************************************************************
localhost                  : ok=3    changed=1    unreachable=0    failed=0

$ ansible-playbook scratch.yml
PLAY [localhost] **********************************************************

TASK [Gathering Facts] ****************************************************
ok: [localhost]

TASK [Ensure templated config is in place] ********************************
ok: [localhost]

TASK [Reload some-service on config change] *******************************
skipping: [localhost]

PLAY RECAP ****************************************************************
localhost                  : ok=2    changed=0    unreachable=0    failed=0
'''.encode('utf-8')) }}

Handlers provide a convenience wrapper for that logic. Rather than `register`ing its output, a task can `notify` a handler. Handlers are defined in the `handlers` block of a play. Since `handlers` aren't executed in the linear manner `tasks` are run, you can quickly reuse the same handler across an entire `tasks` block. By default, `handlers` are queued at the end of each `tasks` without duplication. You can immediately flush the `handlers` queue by including a `meta: flush_handlers` task to override this behavior (do note the queue will still be flushed at the end of the `tasks` block). Like `tasks`, `handlers` are executed linearly in [the order they are defined](http://docs.ansible.com/ansible/latest/playbooks_intro.html#handlers-running-operations-on-change). This provides some structure for handler dependencies and makes notifying multiple handlers easier; after you declare the `handlers` in the order they must be run, you can `notify` them in any order.

Refactoring the leading example gives something like this:

```yaml
...
  tasks:
    - name: Ensure templated config is in place
      template:
        src: etc/some/service.conf.j2
        dest: /etc/some/service.conf
      notify: restart some-service

  handlers:
    - name: restart some-service
      service:
        name: some-service
        state: restarted
...
```

{{ shell_block('''
$ ansible-playbook scratch.yml
PLAY [localhost] **********************************************************

TASK [Gathering Facts] ****************************************************
ok: [localhost]

TASK [Ensure templated config is in place] ********************************
ok: [localhost]

RUNNING HANDLER [restart some-service] ************************************
ok: [localhost]

PLAY RECAP ****************************************************************
localhost                  : ok=3    changed=1    unreachable=0    failed=0

$ ansible-playbook scratch.yml
PLAY [localhost] **********************************************************

TASK [Gathering Facts] ****************************************************
ok: [localhost]

TASK [Ensure templated config is in place] ********************************
ok: [localhost]

PLAY RECAP ****************************************************************
localhost                  : ok=2    changed=0    unreachable=0    failed=0
'''.encode('utf-8')) }}

It's also possible to trigger multiple `handlers` with a single `notify`. Include `listen: 'some string'` in the handler body to add additional `notify` topics. `listen` is [defined as a `list`](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/playbook/handler.py#L28), so you can add multiple triggers if desired.

```yaml
...
  tasks:
    - name: Trigger immediate handler
      command: echo 'By default, command|changed is always true'
      notify: immediate handler

    - name: Immediately flush handlers queue
      meta: flush_handlers

    - name: Trigger named handler
      command: /bin/true
      notify: named handler

    - name: Trigger listen topic
      command: /bin/true
      notify: 'listen topic'

  handlers:
    - name: unnamed handler
      debug:
        msg: 'unnamed handler executed'
      listen:
        - 'listen topic'
        - 'never called topic'

    - name: immediate handler
      debug:
        msg: 'immediate handler executed'

    - name: named handler
      debug:
        msg: 'named handler executed'
      listen: 'listen topic'

    # Removing the name prevents accidental name notification
    # It will only execute on 'listen topic' after the others are finished
    - debug:
        msg: 'order dependent handler executed'
      listen: 'listen topic'
...
```

{{ shell_block('''
$ ansible-playbook scratch.yml
PLAY [localhost] **********************************************************

TASK [Gathering Facts] ****************************************************
ok: [localhost]

TASK [Trigger immediate handler] ******************************************
changed: [localhost]

RUNNING HANDLER [immediate handler] ***************************************
ok: [localhost] => {
    "msg": "immediate handler executed"
}

TASK [Retrigger named handler] ********************************************
changed: [localhost]

TASK [Trigger listen topic] ***********************************************
changed: [localhost]

RUNNING HANDLER [unnamed handler] *****************************************
ok: [localhost] => {
    "msg": "unnamed handler executed"
}

RUNNING HANDLER [named handler] *******************************************
ok: [localhost] => {
    "msg": "named handler executed"
}

RUNNING HANDLER [debug] ***************************************************
ok: [localhost] => {
    "msg": "order dependent handler executed"
}

PLAY RECAP ****************************************************************
localhost                  : ok=8    changed=3    unreachable=0    failed=0
'''.encode('utf-8')) }}

## Roles

Roles provide a way to reuse Ansible code across plays and playbooks. You can think of a `role` as an isolated play that can be inserted anywhere (don't go around the internet quoting me verbatim; while not technically true, it's a good analogy). Roles usually live beside the playbook in the `./roles` (you can specify fancier setups via `roles_path`), and have [a well-defined directory structure](http://docs.ansible.com/ansible/latest/playbooks_reuse_roles.html#role-directory-structure). Instead of being declared in a single file like playbooks, roles are constructed from the contents of their respective directory, `<role path>/<role name>`. Any missing components are simply ignored, although at least one has to exist.

Examples make that wall of text more palatable. Let's recode one of the [Tasks](#tasks) as `roles`. A great starting point is the `package` task. A descriptive name like `installs_common_dependencies` makes it easy to reference. To simply duplicate the task example, this is all that's necessary:

{{ shell_block('''
$ tree roles
roles
└── installs_common_dependencies
    └── tasks
        └── main.yml

2 directories, 1 file
'''.encode('utf-8')) }}

{% raw %}
```yaml
# roles/installs_common_dependencies/tasks/main.yml
---
- name: Ensure dependencies are installed
  package:
    name: "{{ item }}"
    state: present
  with_items:
    - git
    - bash
  become: yes
```
{% endraw %}

The role can now easily be included in a play as a top-level attribute. The `roles` block is compiled to a list of `tasks` and run exactly like a `task` block. `roles` are [run after `pre_tasks` but before `tasks`](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/playbook/play.py#L271).

```yaml
---
- hosts: localhost
  connection: local

  roles:
    - role: installs_common_dependencies

  pre_tasks:
    - debug:
        msg: pre_tasks

  tasks:
    - debug:
        msg: tasks
```

{{ shell_block('''
$ ansible-playbook scratch.yml --ask-become-pass
SUDO password:

PLAY [localhost] **********************************************************

TASK [Gathering Facts] ****************************************************
ok: [localhost]

TASK [debug] **************************************************************
ok: [localhost] => {
    "msg": "pre_tasks"
}

TASK [installs_common_dependencies : Ensure dependencies are installed] ***
ok: [localhost] => (item=git)
ok: [localhost] => (item=bash)

TASK [debug] **************************************************************
ok: [localhost] => {
    "msg": "tasks"
}

PLAY RECAP ****************************************************************
localhost                  : ok=4    changed=0    unreachable=0    failed=0
'''.encode('utf-8')) }}

By default, Ansible searches each block component directory for a `main.yml` file, e.g. Ansible needs `tasks/main.yml` but doesn't care about `files/main.yml` (more on that later). You can include other files in those directories without issue. Ansible will completely ignore them (i.e. anything not `main.yml`) until you explicitly include them.

If we try to run `installs_common_dependencies` on a Windows target, we're going to run into issues. `package` doesn't work on operating systems whose default package manager is Bing via Internet Explorer. Let's expand the tasks to handle different OS families:

{{ shell_block('''
$ tree roles
roles
└── installs_common_dependencies
    └── tasks
        ├── main.yml
        ├── not_windows.yml
        └── windows.yml

2 directories, 3 files
'''.encode('utf-8')) }}

{% raw %}
```yaml
# roles/installs_common_dependencies/tasks/main.yml
---
- include_tasks: windows.yml
  when: ansible_distribution|regex_search('([mM]icrosoft|[wW]indows)')

- include_tasks: not_windows.yml
  when: not ansible_distribution|regex_search('([mM]icrosoft|[wW]indows)')
```
```yaml
# roles/installs_common_dependences/tasks/not_windows.yml
---
- name: Ensure dependencies are installed
  package:
    name: "{{ item }}"
    state: present
  with_items:
    - git
    - bash
  become: yes
```
{% endraw %}
**WARNING:** I haven't actually tested this (or any of following improvements) on a Windows machine because [setting it up](http://docs.ansible.com/ansible/latest/intro_windows.html) requires more time than I feel like spending in PowerShell this weekend. Use at your own risk.
{% raw %}
```yaml
# roles/installs_common_dependences/tasks/windows.yml
---
- name: Badger the user
  debug:
    msg: 'There is hope available--Google "microsoft windows replacement"'

- name: Ensure dependences are installed via chocolatey
  win_chocolatey:
    name: "{{ item }}"
    state: present
  with_items:
    - posh-git

- name: Ensures necessary features are installed
  win_feature:
    name: "{{ item }}"
    state: present
    include_management_tools: yes
    include_sub_features: yes
  register: features_update
  with_items:
    - Windows Subsystem for Linux

- name: Reboot if necessary (usually is)
  win_reboot:
  # I honestly have no idea if this works
  # I also honestly have no idea how to build a context to test it
  when: True in features_update.results|map(attribute='reboot_required')|list|unique
```
{% endraw %}

Splitting out the OS tasks has created a maintenance annoyance: we've now got two files to update when we want to modify the role. Luckily, Ansible has a solid solution for that.

{{ shell_block('''
$ tree roles
roles
└── installs_common_dependencies
    ├── defaults
    │   └── main.yml
    └── tasks
        ├── main.yml
        ├── not_windows.yml
        └── windows.yml

3 directories, 4 files
'''.encode('utf-8')) }}

{% raw %}
```yaml
# roles/installs_common_dependencies/defaults/main.yml
---
common_dependencies:
  easy:
    - git
    - bash
  hard:
    choco:
      - poshgit
    features:
      - Windows Subsystem for Linux
```
```yaml
# roles/installs_common_dependences/tasks/not_windows.yml
---
- name: Ensure dependencies are installed
  package:
    name: "{{ item }}"
    state: present
  with_items: "{{ common_dependencies['easy'] }}"
  become: yes
```
```yaml
# roles/installs_common_dependences/tasks/windows.yml
---
- name: Badger the user
  debug:
    msg: 'There is hope available--Google "microsoft windows replacement"'

- name: Ensure dependences are installed via chocolatey
  win_chocolatey:
    name: "{{ item }}"
    state: present
  with_items: "{{ common_dependencies['hard']['choco'] }}"

- name: Ensures necessary features are installed
  win_feature:
    name: "{{ item }}"
    state: present
    include_management_tools: yes
    include_sub_features: yes
  register: features_update
  with_items: "{{ common_dependencies['hard']['features'] }}"

- name: Reboot if necessary (usually is)
  win_reboot:
  # I honestly have no idea if this works
  # I also honestly have no idea how to build a context to test it
  when: True in features_update.results|map(attribute='reboot_required')|list|unique
```
{% endraw %}

{{ shell_block('''
$ ansible-playbook scratch.yml --ask-become-pass
SUDO password:

PLAY [localhost] **********************************************************

TASK [Gathering Facts] ****************************************************
ok: [localhost]

TASK [installs_common_dependencies : include_tasks] ***********************
skipping: [localhost]

TASK [installs_common_dependencies : include_tasks] ***********************
included: <truncated>/roles/installs_common_dependencies/tasks/not_windows.yml for localhost

TASK [installs_common_dependencies : Ensure dependencies are installed] ***
ok: [localhost] => (item=git)
ok: [localhost] => (item=bash)

PLAY RECAP ****************************************************************
localhost                  : ok=3    changed=0    unreachable=0    failed=0
'''.encode('utf-8')) }}

Roles also provide a local directory for includable files and templates. Any items in `<role name>/files` or `<role name>/templates` can be referenced relatively, rather than trying to piece together an absolute path. If these directories contain a `main.yml`, it won't do anything unless referenced as the target of a module.

We can quickly expand the current example to copy a common `.gitconfig` to the user's home directory. (Note: I'm going to abandon the pretense of Windows support because I have more interesting things to write about. Sorry not sorry.) I like to treat `files` and `templates` as `/`, which makes managing the imports and templates much easier at the cost of lots of directories.

{{ shell_block('''
$ tree roles
roles
└── installs_common_dependencies
    ├── defaults
    │   └── main.yml
    ├── files
    │   └── home
    │       └── user
    │           └── gitconfig
    └── tasks
        ├── main.yml
        ├── not_windows.yml
        └── windows.yml

6 directories, 5 files
'''.encode('utf-8')) }}

{% raw %}
```
# roles/installs_common_dependencies/files/home/user/gitconfig
[help]
        autocorrect = 1
[core]
        autocrlf = input
[push]
        default = matching
```
```yaml
# roles/installs_common_dependences/tasks/not_windows.yml
---
- name: Ensure dependencies are installed
  package:
    name: "{{ item }}"
    state: present
  with_items: "{{ common_dependencies['easy'] }}"
  become: yes

- name: Ensure user gitconfig exists
  copy:
    src: home/user/gitconfig
    dest: "/home/{{ ansible_user }}/.gitconfig"
    force: no
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
    mode: 'ug=rw,o=r'
```
{% endraw %}

{{ shell_block('''
$ ansible-playbook scratch.yml --ask-become-pass
SUDO password:

PLAY [localhost] **********************************************************

TASK [Gathering Facts] ****************************************************
ok: [localhost]

TASK [installs_common_dependencies : include_tasks] ***********************
skipping: [localhost]

TASK [installs_common_dependencies : include_tasks] ***********************
included: <truncated>/roles/installs_common_dependencies/tasks/not_windows.yml for localhost

TASK [installs_common_dependencies : Ensure dependencies are installed] ***
ok: [localhost] => (item=git)
ok: [localhost] => (item=bash)

TASK [installs_common_dependencies : Ensure user gitconfig exists] ********
ok: [localhost]

PLAY RECAP ****************************************************************
localhost                  : ok=4    changed=0    unreachable=0    failed=0
'''.encode('utf-8')) }}

Roles can also include metadata via `<role name>/meta`. At the moment, there are [only three meta attributes](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/playbook/role/metadata.py):

* `allow_duplicates`: This allows a `role` [to be duplicated](http://docs.ansible.com/ansible/latest/playbooks_reuse_roles.html#role-duplication-and-execution) without unique options. By default, a `role` is only executed once per play no matter how many times it's referenced.
* `dependencies`: This list allows you to [prepend any `role` dependencies](http://docs.ansible.com/ansible/latest/playbooks_reuse_roles.html#role-dependencies) before executing the current `role`. The process [loads recursively](https://github.com/ansible/ansible/blob/v2.4.1.0-1/lib/ansible/playbook/role/__init__.py#L278), so you don't have to worry about including dependency dependencies. If the order of inclusion matters, consider setting `allow_duplicates` on the dependencies (but first try to refactor that behavior out).
* `galaxy_info`: This contains metadata for [Ansible Galaxy](https://galaxy.ansible.com/). Ansible Galaxy is a fantastic resource for both great roles and Ansible usage, as it contains roles written by solid developers consumed by users all over (I can say they're written by solid developers because I haven't published any roles yet).

## Recap

Ansible is amazing. By now you should be able to [set its configuration](#configuration), quickly [test tasks](#adhoccommands), [construct playbooks](#playbooks), and create [reusable content](#roles). The best part of this whole post is that I've barely scratched the surface. Google, StackExchange, and the official docs have so many good ideas to try out. There's so much more that I'd love to write about but I really need to publish this and move on to the actual project: automating and securing SSH configuration.

{% endblock %}
